#!/usr/bin/env python3
import os
import vlc
import time
import threading
from tinytag import TinyTag
import random
import fnmatch
import sys
import getopt  # for command line arguments
try:  # to let climp3 start and be usable in non x11 environments (wayland or tty)
    from pynput.keyboard import Key, KeyCode, Listener
except:
    pass


class Controls(object):
    current_play_number = 0
    current_duration = 0
    current_input = ""  # change globals to properties
    current_song_duration = 0
    exit_lock = False

    @staticmethod
    def print_help():
        print("possible inputs:")
        print("  |exit          |stops music and exits mp3Player")
        print("  |play          |starts playlist !When paused, to resume the song type pause again, not play!")
        print("  |cd            |change directory and select single songs")
        print("  |addp          |add the whole current directory to the playlist")
        print("  |showp         |show the current playlist")
        print("  |delp          |stops music and deletes the current playlist")
        print("  |dels          |stops music and deletes songs selectable")
        print("  |show          |shows the current song")
        print("  |pause         |pauses the current song or resumes it")
        print("  |stop          |stops the current song")
        print("  |clear         |clears the command line")
        print("  |skip          |skips the current song")
        print("  |back          |goes back one song")
        print("  |restart       |restarts current song")
        print("  |restartp      |restarts playlist")
        print("  |togglemute    |toggles mute of this player")
        print("  |mute          |mutes this player")
        print("  |unmute        |unmutes this player")
        print("  |ismute        |outputs mute status")
        print("  |getvolume     |outputs volume")
        print("  |setvolume     |sets  volume")
        print("  |sortp         |stops music and sorts playlist after track number")
        print("  |skipto        |stops music and skips to entered song number")
        print("  |shufflep      |stops music and randomizes playlist")
        print("  |search        |searches for files")
        print("  |toend         |shows time left of song")
        print("  |tostart       |shows time already played of song")
        print("  |length        |shows length of song")
        print("  |seek [x]      |skips x seconds")
        print("  |setchapter    |set chapter")
        print("  |getchapter    |get current chapter")

    # noinspection PyCallByClass
    @staticmethod
    def unmute():
        Song.player.audio_set_mute(False)
        print("|::| Unmuted")

    @staticmethod
    def ismute():
        if Song.player.audio_get_mute() == 0:
            print("|::|Player is not muted")
        else:
            print("|::|Player is muted")

    @staticmethod
    def mute():
        Song.player.audio_set_mute(True)
        print("|::| Muted")

    @staticmethod
    def toggle_mute():
        Song.player.audio_toggle_mute()
        print("|::| Mute toggled")

    @staticmethod
    def getvolume():
        print("|::| Volume:  " + str(Song.player.audio_get_volume()) + "%")

    # noinspection PyCallByClass
    @staticmethod
    def setvolume():
        print("Set Volume to[%, 1-100]: ", end="")
        try:
            next_volume = int(input())
            if next_volume > 100 or next_volume < 1:  # to make sure volume is between 1 and 100
                raise ValueError
        except ValueError:
            print("Please enter a valid number")
            return
        Song.player.audio_set_volume(next_volume)

    # noinspection PyCallByClass
    @staticmethod
    def setvolume2():
        try:
            next_volume = int(Controls.current_input[10:])
            if next_volume > 100 or next_volume < 1:  # to make sure volume is between 1 and 100
                raise ValueError
        except ValueError:
            print("Please enter a valid number")
            return
        Song.player.audio_set_volume(next_volume)

    @staticmethod
    def setchapter():
        print("Set chapter to[" + str(Song.player.get_chapter()) + ":" + str(Song.player.get_chapter_count()) + "]: ", end="")
        try:
            next_chapter = int(input())
            if next_chapter > Song.player.get_chapter_count() or next_chapter < 0:
                raise ValueError
        except ValueError:
            print("Please enter a valid number")
            return
        Song.player.set_chapter(next_chapter)

    @staticmethod
    def setchapter2():
        try:
            next_chapter = int(Controls.current_input[10:])
            if next_chapter > Song.player.get_chapter_count() or next_chapter < 0:
                raise ValueError
        except ValueError:
            print("Please enter a valid number")
            return
        Song.player.set_chapter(next_chapter)

    @staticmethod
    def skip():
        if len(PlayList.playlist) == 0:
            print("|EE| You have currently no playlist")
            return
        Song.player.stop()
        Song.elapsed_song = 0

        if Controls.current_play_number + 1 >= len(PlayList.playlist):  # ends playlist
            Controls.current_play_number = 0
            print("Finished playing playlist")
            return

        Controls.current_play_number += 1
        threading.Thread(target=Song.play, args=(False,), kwargs={}).start()  # start next song

    @staticmethod
    def back():
        if len(PlayList.playlist) == 0:
            print("|EE| You have currently no playlist")
            return
        if Controls.current_play_number == 0:
            print("|EE| This is the first song in the playlist")
            return

        Song.player.stop()
        Song.elapsed_song = 0
        Controls.current_play_number -= 1
        threading.Thread(target=Song.play, args=(True,), kwargs={}).start()

    @staticmethod
    def restart():
        if len(PlayList.playlist) == 0:
            print("|EE| You have currently no playlist")
            return

        Song.player.stop()
        Song.elapsed_song = 0
        threading.Thread(target=Song.play, args=(True,), kwargs={}).start()


class Directory(object):
    patterns = list()
    patterns.extend(['*.mp3', '*.m4a', '*.flac', '*.wma', '*.wav'])

    @staticmethod
    def is_media_playable(media_path):
        media = vlc.MediaPlayer(media_path).get_media()
        media.parse()
        return media.get_duration()

    @staticmethod
    def cd_go_back():
        os.system('clear')  # only in terminal, not cross-compatible
        old_path = os.getcwd()  # is need to always get one level higher up in the folder system
        current_i = len(old_path) - 1
        is_before_new_path = True
        new_path = ""  # bad name, new_path is the one that is one level higher up in the folder system
        while current_i > 0:
            if old_path[current_i] == '/':
                is_before_new_path = False

            if not is_before_new_path:
                new_path += old_path[current_i]

            current_i -= 1

        os.chdir('/' + new_path[::-1])  # [::-1] reverses string, because the while loop started from behind

    @staticmethod
    def cd_subfolder(subfolder_name, is_recursive):
        os.system('clear')  # only in terminal
        if not os.path.isdir(subfolder_name) and not is_recursive:  # doesn't check for songs, only enters subfolders
            file_extension = os.path.splitext(subfolder_name)[1]
            if '*' + file_extension in Directory.patterns:
                PlayList.playlist.append(subfolder_name)
            return

        try:
            os.chdir(subfolder_name)
        except OSError:
            print("|EE| Unable to enter folder")

    @staticmethod
    def input_directories():
        while True:  # breaks out of loop, instead of creating extra variable, for convenience
            os.system('clear')  # only in terminal
            print('Select from 0 to ' + str(len(os.listdir(os.getcwd()))))
            print("-1:/Exit from file/directory search")
            print("0:/..")
            current_i = 1  # to be able to print numbers in front of subdirectories
            for current_subfolder in os.listdir(os.getcwd()):  # outputs the current subfolders
                print(str(current_i) + ":/" + current_subfolder)
                current_i += 1
            sub_folder_number = 0
            print(":>", end="")  # line before input
            try:
                sub_folder_number = int(input())
            except ValueError:
                pass  # Because it's so easily overlooked and pretty annoying

            if sub_folder_number == 0:
                Directory.cd_go_back()
            elif sub_folder_number == -1:  # exit the music/folder selector
                return
            elif len(os.listdir(os.getcwd())) >= sub_folder_number > 0:
                Directory.cd_subfolder(os.getcwd() + '/' + os.listdir(".")[sub_folder_number - 1], False)

    @staticmethod
    def search():
        print("Search for: ", end="")
        pattern = input()
        pattern = "*" + pattern + "*"
        root_path = os.getcwd()
        for root, dirs, files in os.walk(root_path):
            for filename in fnmatch.filter(files, pattern):
                print(os.path.join(root, filename).replace(root_path, ''))

    @staticmethod
    def search2():
        pattern = Controls.current_input[7:]
        pattern = "*" + pattern + "*"
        root_path = os.getcwd()
        for root, dirs, files in os.walk(root_path):
            for filename in fnmatch.filter(files, pattern):
                print(os.path.join(root, filename).replace(root_path, ''))


class PlayList(object):
    playlist = list()

    @staticmethod
    def restart_playlist():
        if len(PlayList.playlist) == 0:
            print("|EE| You have currently no playlist")
            return
        Song.player.stop()
        Song.elapsed_song = 0

        Controls.current_play_number = 0
        threading.Thread(target=Song.play, args=(True,), kwargs={}).start()

    @staticmethod
    def delete_song():
        # Song.player.stop()
        print("Remove song[s] from playlist: ", end="")
        pattern = input()
        PlayList.playlist[:] = [x for x in PlayList.playlist if pattern not in x]

    @staticmethod
    def delete_song2():
        # Song.player.stop()
        pattern = Controls.current_input[5:]
        PlayList.playlist[:] = [x for x in PlayList.playlist if pattern not in x]

    @staticmethod
    def delete_playlist():
        Song.player.stop()
        Song.elapsed_song = 0
        print("|::| deleting the current playlist")
        Controls.current_play_number = 0
        PlayList.playlist.clear()

    @staticmethod
    def add():
        root_path = os.getcwd()
        for pattern in Directory.patterns:
            for root, dirs, files in os.walk(root_path):
                for filename in fnmatch.filter(files, pattern):
                    PlayList.playlist.append(os.path.join(root, filename))  # actually adding to playlist

    @staticmethod
    def format_time(whole_time):
        hour = whole_time // 3600
        whole_time %= 3600
        minutes = whole_time // 60
        whole_time %= 60
        seconds = whole_time
        print("Duration: %d:%d:%d" % (hour, minutes, seconds))

    @staticmethod
    def show_playlist():
        os.system('clear')  # only in terminal
        playlist_duration = 0
        wrong_type = False

        for current_song in PlayList.playlist:
            audiofile = TinyTag.get(current_song)
            try:
                playlist_duration += int(audiofile.duration)
            except TypeError:
                wrong_type = True
            print(str(PlayList.playlist.index(current_song) + 1) + "|: ", end="")
            if audiofile.artist and audiofile.title:
                print(audiofile.artist + ' - ' + audiofile.title)
            else:  # if there are no tags
                print(current_song)  # just print the filename with the whole file path

        PlayList.format_time(playlist_duration)
        if wrong_type:
            print("One or more files gave back a wrong audio duration")

    @staticmethod
    def sort():
        Song.player.stop()
        Song.elapsed_song = 0
        Controls.current_play_number = 0
        exchange = True
        while exchange:
            exchange = False
            for i1 in range(len(PlayList.playlist) - 1):
                audiofile1 = TinyTag.get(PlayList.playlist[i1])
                audiofile2 = TinyTag.get(PlayList.playlist[i1 + 1])
                if not audiofile1.track:
                    print("|EE| At least one song has no valid tags")
                    return

                if int(audiofile1.track) > int(audiofile2.track):
                    exchange = True
                    temp = PlayList.playlist[i1]
                    PlayList.playlist[i1] = PlayList.playlist[i1 + 1]
                    PlayList.playlist[i1 + 1] = temp

    @staticmethod
    def shuffle_playlist():
        Song.player.stop()
        Song.elapsed_song = 0
        Controls.current_play_number = 0
        print("shuffling Playlist")
        random.shuffle(PlayList.playlist)


class Song(object):
    player = vlc.MediaPlayer("")

    @staticmethod
    def show():
        if len(PlayList.playlist) == 0:
            print('|EE|: no selected song')
            return
        audiofile = TinyTag.get(PlayList.playlist[Controls.current_play_number])

        if audiofile.artist and audiofile.title:
            print(audiofile.artist + ' - ' + audiofile.title)
        if audiofile.album:
            print('Album: ' + audiofile.album)
        if audiofile.track:
            print('Track number: ' + str(int(audiofile.track[0])))
        if audiofile.duration:
            print('Song ', end='')
            PlayList.format_time(audiofile.duration)
        if audiofile.year:
            print('Release year: ' + str(audiofile.year))
        if audiofile.genre:
            print('Genre: ' + audiofile.genre)
        if audiofile.track_total:
            print('Total track count: ' + str(audiofile.track_total))
        if audiofile.albumartist:
            print('Album artist: ' + audiofile.albumartist)
        if audiofile.bitrate:
            print('Track bitrate: ' + str(round(audiofile.bitrate, 1)))
        if audiofile.composer:
            print('Composer: ' + audiofile.composer)
        if audiofile.disc:
            print('Disc: ' + str(audiofile.disc))
        if audiofile.disc_total:
            print('Total disc: ' + str(audiofile.disc_total))
        if audiofile.comment:
            print("Track comment: " + audiofile.comment)
        if audiofile.channels:
            print('Track channels: ' + str(audiofile.channels))
        if audiofile.audio_offset:
            print('Audio offset: ' + str(audiofile.audio_offset))
        print('Path:  ' + PlayList.playlist[Controls.current_play_number])

    @staticmethod
    def play(dummy1):
        time.sleep(1)
        if str(Song.player.get_state()) == "State.Playing":
            return
        if len(PlayList.playlist) == 0:
            print("|EE| You have currently no playlist")
            return

        audiofile = TinyTag.get(PlayList.playlist[Controls.current_play_number])
        print("", end="\r")  # clears current line

        if audiofile.artist and audiofile.title:
            print('|' + str(Controls.current_play_number + 1) + '::' + str(len(PlayList.playlist)) + '| Now playing: ' +
                  audiofile.artist + ' - ' + audiofile.title, end="")
        else:  # if there are no tags
            print('|' + str(Controls.current_play_number + 1) + '::' + str(len(PlayList.playlist)) + '| Now playing: ' +
                  PlayList.playlist[Controls.current_play_number], end="")

        print('\n>', end="")
        Song.player = vlc.MediaPlayer("file://" + PlayList.playlist[Controls.current_play_number])
        Song.player.play()

        duration = int(audiofile.duration) * 1000
        Controls.current_duration = duration
        while Song.player.get_time() <= duration:
            while str(Song.player.get_state()) == "State.Paused" or str(Song.player.get_state()) == "State.Stopped":
                if Controls.exit_lock:
                    return
                time.sleep(1)  # to not progress the for loop while paused/stopped
            time.sleep(1)
            if (duration != Controls.current_duration) or Controls.exit_lock:  # Trick to kill thread, when
                return  # duration of the song is not the same as most recent song, then the thread gets killed

        if Controls.current_play_number + 1 < len(PlayList.playlist):
            Controls.current_play_number += 1
            threading.Thread(target=Song.play, args=(True,), kwargs={}).start()  # recursive calling to play next song
        else:
            print("\n|::| Finished playing Playlist\n>", end="")

    @staticmethod
    def skipto():
        if len(PlayList.playlist) == 0:
            print("|EE| You have currently no playlist")
            return
        print("Skip to track number: ", end="")

        try:
            raw_input = int(input()) - 1
            if raw_input > len(PlayList.playlist) or raw_input < 0:
                raise TypeError
        except TypeError:
            print("|EE| Please enter a valid number")
            return

        Song.player.stop()
        Controls.current_play_number = raw_input
        threading.Thread(target=Song.play, args=(True,), kwargs={}).start()  # old thread get killed automatically

    @staticmethod
    def skipto2():
        if len(PlayList.playlist) == 0:
            print("|EE| You have currently no playlist")
            return

        try:
            raw_input = int(Controls.current_input[6:]) - 1
            if raw_input > len(PlayList.playlist) or raw_input < 0:
                raise TypeError
        except TypeError:
            return

        Song.player.stop()
        Controls.current_play_number = raw_input
        threading.Thread(target=Song.play, args=(True,), kwargs={}).start()  # start new thread, old thread get killed


def media_buttons(key):
    if not hasattr(key, 'vk'):
        return
    if key.vk == 269025047:
        Controls.skip()
    elif key.vk == 269025046:
        Controls.back()
    elif key.vk == 269025045:
        if str(Song.player.get_state()) == "State.Playing":
            Song.player.stop()
        elif str(Song.player.get_state()) == "State.Stopped":
            threading.Thread(target=Song.play, args=(True,), kwargs={}).start()
    elif key.vk == 269025044:
        if str(Song.player.get_state()) == "State.Playing" or str(Song.player.get_state()) == "State.Paused":
            Song.player.pause()
            print("\rPause / Play\n>", end="")
        else:
            threading.Thread(target=Song.play, args=(True,), kwargs={}).start()


def main(argv):  # args
    try:
        opts, args = getopt.getopt(argv, "hav", ["addp", "help", "version"])
    except getopt.GetoptError:
        Controls.print_help()
        sys.exit(2)
    for opt, arg in opts:
        if opt in ('-h', "--help"):
            Controls.print_help()
            sys.exit()
        elif opt in ("-a", "--addp"):
            PlayList.add()
            print('added directory to playlist')
        elif opt in ("-v", "--version"):
            print('Version climp3 1.6.0')
            sys.exit()


if __name__ == "__main__":
    main(sys.argv[1:])


for argv_song in sys.argv:
    argv_extension = os.path.splitext(argv_song)[1]
    if '*' + argv_extension in Directory.patterns:
        if argv_song[0] != "/":
            PlayList.playlist.append(os.getcwd() + "/" + argv_song)
        else:
            PlayList.playlist.append(argv_song)


def media_buttons_listener(dummy_media):
    try:
        with Listener(on_press=media_buttons):
            while not Controls.exit_lock:
                time.sleep(1)
            return
    except:
        return


threading.Thread(target=media_buttons_listener, args=(True,), kwargs={}).start()
print("\n|;;| Current Directory: " + os.getcwd())
while Controls.current_input != "exit":  # this while could be True because the effective exit is with a elif/break
    print(">", end="")
    try:
        Controls.current_input = input()
    except ValueError:  # if no string is entered (maybe not even possible)
        print("Wrong input, try again")

    if Controls.current_input == "cd":
        Directory.input_directories()

    elif Controls.current_input == "addp":
        PlayList.add()

    elif Controls.current_input == "showp":
        PlayList.show_playlist()

    elif Controls.current_input == "show":
        Song.show()

    elif Controls.current_input == "play":
        threading.Thread(target=Song.play, args=(True,), kwargs={}).start()

    elif Controls.current_input == "pause":
        Song.player.pause()
        print("\rPause / Play\n", end="")

    elif Controls.current_input == "stop":
        Song.player.stop()

    elif Controls.current_input == "delp":
        PlayList.delete_playlist()

    elif Controls.current_input == "dels":
        PlayList.delete_song()

    elif Controls.current_input[:4] == "dels":
        PlayList.delete_song2()

    elif Controls.current_input == "clear":
        os.system('clear')  # not cross compatible, only in terminal

    elif Controls.current_input == "togglemute":
        Controls.toggle_mute()

    elif Controls.current_input == "mute":
        Controls.mute()

    elif Controls.current_input == "unmute":
        Controls.unmute()

    elif Controls.current_input == "ismute":
        Controls.ismute()

    elif Controls.current_input == "getvolume":
        Controls.getvolume()

    elif Controls.current_input == "setvolume":
        Controls.setvolume()

    elif Controls.current_input[:9] == "setvolume":
        Controls.setvolume2()

    elif Controls.current_input == "skip":
        Controls.skip()

    elif Controls.current_input == "back":  # exactly the same as skip, except reversed
        Controls.back()

    elif Controls.current_input == "restart":
        Controls.restart()

    elif Controls.current_input == "restartp":
        PlayList.restart_playlist()

    elif Controls.current_input == "sortp":
        PlayList.sort()

    elif Controls.current_input == "shufflep":
        PlayList.shuffle_playlist()

    elif Controls.current_input == "search":
        Directory.search()

    elif Controls.current_input[:6] == "search":
        Directory.search2()

    elif Controls.current_input == "help":
        Controls.print_help()

    elif Controls.current_input == "skipto":
        Song.skipto()

    elif Controls.current_input[:6] == "skipto":
        Song.skipto2()

    elif Controls.current_input == "toend":
        print("Time to end of song: " + str(int((Song.player.get_length() - Song.player.get_time()) /1000)) + " seconds")

    elif Controls.current_input == "tostart":
        print("Elapsed Time: " + str(int(Song.player.get_time() / 1000)) + " seconds")

    elif Controls.current_input == "length":
        print("Length: " + str(Song.player.get_length() / 1000))

    elif Controls.current_input == "seek":
        Song.player.set_time(Song.player.get_time() + 10000)

    elif Controls.current_input[:4] == "seek":
        try:
            seek_time = int(Controls.current_input[4:]) * 1000
        except ValueError:
            pass
        Song.player.set_time(Song.player.get_time() + seek_time)

    elif Controls.current_input == "getchapter":
        print("Chapter: " + str(Song.player.get_chapter()))

    elif Controls.current_input == "setchapter":
        Controls.setchapter()

    elif Controls.current_input[:10] == "setchapter":
        Controls.setchapter2()

    elif Controls.current_input == "exit":
        Controls.exit_lock = True
        break

sys.exit()
