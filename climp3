#!/usr/bin/env python3
import os
from threading import Thread

import vlc
import time
import threading
from tinytag import TinyTag
import random
import fnmatch


class Controls(object):
    current_play_number = 0
    current_duration = 0
    current_input = ""  # change globals to properties
    current_song_duration = 0

    # noinspection PyCallByClass
    @staticmethod
    def unmute():
        Song.player.audio_set_mute(False)
        print("|::| Unmuted")

    @staticmethod
    def ismute():
        if Song.player.audio_get_mute() == 0:
            print("|::|Player is not muted")
        else:
            print("|::|Player is muted")

    @staticmethod
    def mute():
        Song.player.audio_set_mute(True)
        print("|::| Muted")

    @staticmethod
    def toggle_mute():
        Song.player.audio_toggle_mute()
        print("|::| Mute toggled")

    @staticmethod
    def getvolume():
        print("|::| Volume:  " + str(Song.player.audio_get_volume()) + "%")

    # noinspection PyCallByClass
    @staticmethod
    def setvolume():
        print("Set Volume to[%, 1-100]: ", end="")
        try:
            next_volume = int(input())
            if next_volume > 100 or next_volume < 1:  # to make sure volume is between 1 and 100
                raise ValueError
        except ValueError:
            print("Please enter a valid number")
            return
        Song.player.audio_set_volume(next_volume)

    # noinspection PyCallByClass
    @staticmethod
    def setvolume2():
        try:
            next_volume = int(Controls.current_input[10:])
            if next_volume > 100 or next_volume < 1:  # to make sure volume is between 1 and 100
                raise ValueError
        except ValueError:
            print("Please enter a valid number")
            return
        Song.player.audio_set_volume(next_volume)

    @staticmethod
    def skip():
        dummy1 = False  # idk why this is needed
        if len(PlayList.playlist) is 0:
            print("|EE| You have currently no playlist")
            return
        Song.player.stop()

        if Controls.current_play_number + 1 >= len(PlayList.playlist):  # ends playlist
            Controls.current_play_number = 0
            print("Finished playing playlist")
            return

        Controls.current_play_number += 1
        thr1 = threading.Thread(target=Song.play, args=(dummy1,), kwargs={})
        thr1.start()  # start next song

    @staticmethod
    def back():
        dummy1 = False  # still no idea
        if len(PlayList.playlist) is 0:
            print("|EE| You have currently no playlist")
            return
        if Controls.current_play_number is 0:
            print("|EE| This is the first song in the playlist")
            return

        Song.player.stop()
        Controls.current_play_number -= 1
        thr1 = threading.Thread(target=Song.play, args=(dummy1,), kwargs={})
        thr1.start()

    @staticmethod
    def restart():
        dummy1 = False  # because of threads
        if len(PlayList.playlist) is 0:
            print("|EE| You have currently no playlist")
            return

        thr1 = threading.Thread(target=Song.play, args=(dummy1,), kwargs={})
        thr1.start()


class Directory(object):
    @staticmethod
    def cd_go_back():
        os.system('clear')  # only in terminal, not cross-compatible
        old_path = os.getcwd()  # is need to always get one level higher up in the folder system
        i = len(old_path) - 1
        is_before_new_path = True
        new_path = ""  # bad name, new_path is the one that is one level higher up in the folder system
        while i > 0:
            if old_path[i] == '/':
                is_before_new_path = False

            if not is_before_new_path:
                new_path += old_path[i]

            i -= 1

        os.chdir('/' + new_path[::-1])  # [::-1] reverses string, because the while loop started from behind

    @staticmethod
    def cd_subfolder(subfolder_number, is_recursive):
        os.system('clear')  # only in terminal
        subfolder_name = os.listdir(os.getcwd())[subfolder_number - 1]  # only the number of the subfolder gets passed,
        # for simplicity reasons
        if not os.path.isdir(subfolder_name) and not is_recursive:  # doesn't check for songs, only enters subfolders
            PlayList.add_song(subfolder_number - 1)  # adds song to playlist if number is pressed
            return  # subfolder - 1 is because Playlist.add_song needs only the numbers, too

        try:
            os.chdir(os.getcwd() + "/" + subfolder_name)
        except OSError:
            print("|EE| Unable to enter Folder")

    @staticmethod
    def input_directories():
        while True:  # breaks out of loop, instead of creating extra variable, for convenience
            os.system('clear')  # only in terminal
            print('Select from 0 to ' + str(len(os.listdir(os.getcwd()))))
            print("-1:/Exit from file/directory search")
            print("0:/..")
            i = 1  # to be able to print numbers in front of subdirectories
            for current_subfolder in os.listdir(os.getcwd()):  # outputs the current subfolders
                print(str(i) + ":/" + current_subfolder)
                i += 1
            sub_folder_number = 0
            print(":>", end="")  # line before input
            try:
                sub_folder_number = int(input())
            except ValueError:
                pass  # Because it's so easily overlooked and pretty annoying

            if sub_folder_number == 0:
                Directory.cd_go_back()
            elif sub_folder_number == -1:  # exit the music/folder selector
                return
            elif len(os.listdir(os.getcwd())) >= sub_folder_number > 0:
                Directory.cd_subfolder(sub_folder_number, False)  # changes wd to selected subfolder


class PlayList(object):
    playlist = list()

    @staticmethod
    def restart_playlist():
        dummy1 = False
        if len(PlayList.playlist) is 0:
            print("|EE| You have currently no playlist")
            return
        Song.player.stop()

        Controls.current_play_number = 0
        thr1 = threading.Thread(target=Song.play, args=(dummy1,), kwargs={})
        thr1.start()

    @staticmethod
    def delete_playlist():
        Song.player.stop()
        print("|::| deleting the current playlist")
        Controls.current_play_number = 0
        PlayList.playlist.clear()

    @staticmethod
    def add():
        length = len(os.listdir(os.getcwd()))
        i = 0
        while i < length:  # going through every file or directory in the current folder
            PlayList.add_song(i)
            root_path = os.getcwd() + "/" + os.listdir(os.getcwd())[i]
            pattern = '*.flac'
            for root, dirs, files in os.walk(root_path):
                for filename in fnmatch.filter(files, pattern):
                    PlayList.playlist.append(os.path.join(root, filename))  # actually adding to playlist
            pattern = '*.mp3'
            for root, dirs, files in os.walk(root_path):
                for filename in fnmatch.filter(files, pattern):
                    PlayList.playlist.append(os.path.join(root, filename))  # actually adding to playlist
            i += 1  # while loop looks better than for loop in this application (only in python3)

    @staticmethod
    def add_song(file_number):  # is in an extra method because it's needed quite often
        current_file = os.listdir(os.getcwd())[file_number]
        if current_file.endswith(".mp3") or current_file.endswith(".flac"):
            PlayList.playlist.append(os.getcwd() + "/" + current_file)

    @staticmethod
    def format_time(whole_time):
        hour = whole_time // 3600
        whole_time %= 3600
        minutes = whole_time // 60
        whole_time %= 60
        seconds = whole_time
        print("Duration: %d:%d:%d" % (hour, minutes, seconds))

    @staticmethod
    def show_playlist():
        os.system('clear')  # only in terminal
        i = 0
        playlist_duration = 0

        while i < len(PlayList.playlist):  # every song in the playlist
            audiofile = TinyTag.get(PlayList.playlist[i])
            playlist_duration += int(audiofile.duration)  # count playlist duration

            print(str(i + 1) + "|: ", end="")
            if audiofile.artist and audiofile.title:
                print(audiofile.artist + ' - ' + audiofile.title)
            else:  # if there are no tags
                print(PlayList.playlist[i])  # just print the filename with the whole file path
            i += 1

        PlayList.format_time(playlist_duration)

    @staticmethod
    def sort():
        Song.player.stop()
        Controls.current_play_number = 0
        exchange = True
        while exchange:
            exchange = False
            for i1 in range(len(PlayList.playlist) - 1):
                audiofile1 = TinyTag.get(PlayList.playlist[i1])
                audiofile2 = TinyTag.get(PlayList.playlist[i1 + 1])
                if not audiofile1.track:
                    print("|EE| At least one song has no valid tags")
                    return

                if int(audiofile1.track) > int(audiofile2.track):
                    exchange = True
                    temp = PlayList.playlist[i1]
                    PlayList.playlist[i1] = PlayList.playlist[i1 + 1]
                    PlayList.playlist[i1 + 1] = temp

    @staticmethod
    def shuffle_playlist():
        Song.player.stop()
        Controls.current_play_number = 0
        print("shuffling Playlist")
        random.shuffle(PlayList.playlist)


class Song(object):
    player = vlc.MediaPlayer("")

    @staticmethod
    def show():
        if len(PlayList.playlist) is 0:
            print('|EE|: no selected song')
            return
        audiofile = TinyTag.get(PlayList.playlist[Controls.current_play_number])

        if audiofile.artist and audiofile.title:
            print(audiofile.artist + ' - ' + audiofile.title)
        if audiofile.album:
            print('Album: ' + audiofile.album)
        if audiofile.track:
            print('Track number: ' + str(int(audiofile.track[0])))
        if audiofile.duration:
            print('Song duration: ', end='')
            PlayList.format_time(audiofile.duration)
        if audiofile.year:
            print('Release year: ' + str(audiofile.year))
        if audiofile.genre:
            print('Genre: ' + audiofile.genre)
        if audiofile.track_total:
            print('Total track count: ' + str(audiofile.track_total))
        if audiofile.albumartist:
            print('Album artist: ' + audiofile.albumartist)
        if audiofile.bitrate:
            print('Track bitrate: ' + str(round(audiofile.bitrate, 1)))
        if audiofile.composer:
            print('Composer: ' + audiofile.composer)
        if audiofile.disc:
            print('Disc: ' + str(audiofile.disc))
        if audiofile.disc_total:
            print('Total disc: ' + str(audiofile.disc_total))
        if audiofile.comment:
            print("Track comment: " + audiofile.comment)
        if audiofile.channels:
            print('Track channels: ' + str(audiofile.channels))
        if audiofile.audio_offset:
            print('Audio offset: ' + str(audiofile.audio_offset))
        print('Path:  ' + PlayList.playlist[Controls.current_play_number])

    @staticmethod
    def play(dummy1):
        if len(PlayList.playlist) is 0:
            print("|EE| You have currently no playlist")
            return

        audiofile = TinyTag.get(PlayList.playlist[Controls.current_play_number])
        print("", end="\r")  # clears current line

        if audiofile.artist and audiofile.title:
            print('|' + str(Controls.current_play_number + 1) + '::' + str(len(PlayList.playlist)) + '| Now playing: ' +
                  audiofile.artist + ' - ' + audiofile.title, end="")
        else:  # if there are no tags
            print('|' + str(Controls.current_play_number + 1) + '::' + str(len(PlayList.playlist)) + '| Now playing: ' +
                  PlayList.playlist[Controls.current_play_number], end="")

        print('\n>', end="")
        Song.player = vlc.MediaPlayer("file://" + PlayList.playlist[Controls.current_play_number])
        Song.player.play()

        duration = int(audiofile.duration)
        Controls.current_duration = duration
        for i in range(0, int(duration)):
            while str(Song.player.get_state()) == "State.Paused" or str(Song.player.get_state()) == "State.Stopped":
                time.sleep(1)  # to not progress the for loop while paused/stopped
            time.sleep(1)
            if duration is not Controls.current_duration:  # Trick to kill thread when a song is skipped: when the
                return  # duration of the song is not the same as most recent song, then the thread gets killed

        if Controls.current_play_number + 1 < len(PlayList.playlist):
            Controls.current_play_number += 1
            thr1: Thread = threading.Thread(target=Song.play, args=(dummy1,), kwargs={})
            thr1.start()  # recursive calling to play next song
        else:
            print("\n|::| Finished playing Playlist\n>", end="")

    @staticmethod
    def skipto():
        dummy1 = False
        if len(PlayList.playlist) is 0:
            print("|EE| You have currently no playlist")
            return
        print("Skip to track number: ", end="")

        try:
            raw_input = int(input()) - 1
            if raw_input > len(PlayList.playlist) or raw_input < 0:
                raise TypeError
        except TypeError:
            print("|EE| Please enter a valid number")
            return

        Song.player.stop()
        Controls.current_play_number = raw_input
        thr1 = threading.Thread(target=Song.play, args=(dummy1,), kwargs={})
        thr1.start()  # old thread get killed automatically by trick

    @staticmethod
    def skipto2():
        dummy1 = False
        if len(PlayList.playlist) is 0:
            print("|EE| You have currently no playlist")
            return

        try:
            raw_input = int(Controls.current_input[6:]) - 1
            if raw_input > len(PlayList.playlist) or raw_input < 0:
                raise TypeError
        except TypeError:
            return

        Song.player.stop()
        Controls.current_play_number = raw_input
        thr1 = threading.Thread(target=Song.play, args=(dummy1,), kwargs={})
        thr1.start()  # start new thread, old thread get killed automatically by trick


print("\n|;;| Current Directory: " + os.getcwd())
while Controls.current_input is not "exit":  # this while could be True because the effective exit is with a elif/break
    print(">", end="")
    try:
        Controls.current_input = input()
    except ValueError:  # if no string is entered (maybe not even possible)
        print("Wrong input, try again")

    if Controls.current_input == "cd":
        Directory.input_directories()

    elif Controls.current_input == "addp":
        PlayList.add()

    elif Controls.current_input == "showp":
        PlayList.show_playlist()

    elif Controls.current_input == "show":
        Song.show()

    elif Controls.current_input == "play":
        dummy = True  # still no idea why threads always need an extra argument, kinda dumb
        thr = threading.Thread(target=Song.play, args=(dummy,), kwargs={})
        thr.start()

    elif Controls.current_input == "pause":
        Song.player.pause()

    elif Controls.current_input == "stop":
        Song.player.stop()

    elif Controls.current_input == "delp":
        PlayList.delete_playlist()

    elif Controls.current_input == "clear":
        os.system('clear')  # not cross compatible, only in terminal

    elif Controls.current_input == "togglemute":
        Controls.toggle_mute()

    elif Controls.current_input == "mute":
        Controls.mute()

    elif Controls.current_input == "unmute":
        Controls.unmute()

    elif Controls.current_input == "ismute":
        Controls.ismute()

    elif Controls.current_input == "getvolume":
        Controls.getvolume()

    elif Controls.current_input == "setvolume":
        Controls.setvolume()

    elif Controls.current_input[:9] == "setvolume":
        Controls.setvolume2()

    elif Controls.current_input == "skip":
        Controls.skip()

    elif Controls.current_input == "back":  # exactly the same as skip, except reversed
        Controls.back()

    elif Controls.current_input == "restart":
        Controls.restart()

    elif Controls.current_input == "restartp":
        PlayList.restart_playlist()

    elif Controls.current_input == "sortp":
        PlayList.sort()

    elif Controls.current_input == "shufflep":
        PlayList.shuffle_playlist()

    elif Controls.current_input == "help":
        print("possible inputs:")
        print("  |exit          |stops music and exits mp3Player")
        print("  |play          |starts playlist !When paused, to resume the song type pause again, not play!")
        print("  |cd            |change directory and select single songs")
        print("  |addp          |add the whole current directory to the playlist")
        print("  |showp         |show the current playlist")
        print("  |delp          |stops music and deletes the current playlist")
        print("  |show          |shows the current song")
        print("  |pause         |pauses the current song or resumes it")
        print("  |stop          |stops the current song")
        print("  |clear         |clears the command line")
        print("  |skip          |skips the current song")
        print("  |back          |goes back one song")
        print("  |restart       |restarts current song")
        print("  |restartp      |restarts playlist")
        print("  |togglemute    |toggles mute of this player")
        print("  |mute          |mutes this player")
        print("  |unmute        |unmutes this player")
        print("  |ismute        |outputs mute status")
        print("  |getvolume     |outputs volume")
        print("  |setvolume     |sets  volume")
        print("  |sortp         |stops music and sorts playlist after track number")
        print("  |skipto        |stops music and skips to entered song number")
        print("  |shufflep      |stops music and randomizes playlist")

    elif Controls.current_input == "skipto":
        Song.skipto()

    elif Controls.current_input[:6] == "skipto":
        Song.skipto2()

    elif Controls.current_input == "exit":
        break

os.system('pkill python3')
