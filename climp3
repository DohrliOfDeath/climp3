#!/usr/bin/env python3
import os
import vlc
import time
import threading
import eyed3
import random
import fnmatch


class Controls(object):
    current_play_number = 0
    current_duration = 0
    current_input = ""  # change globals to properties
    current_song_duration = 0

    # noinspection PyCallByClass
    @staticmethod
    def unmute():
        try:
            Song.player.audio_set_mute(False)
        except NameError:
            player_not_defined()
        print("|::| Unmuted")

    @staticmethod
    def getvolume():
        try:
            print("|::| Volume:  ", end="")
            print(Song.player.audio_get_volume(), end="")
        except NameError:
            player_not_defined()
        print("%")

    # noinspection PyCallByClass
    @staticmethod
    def setvolume():
        try:
            print("Set Volume to[%, 0-100]: ", end="")
            Song.player.audio_set_volume(int(input()))
        except NameError:
            player_not_defined()
        except ValueError:
            print("Please enter a valid number")

    # noinspection PyCallByClass
    @staticmethod
    def setvolume2():
        try:
            Song.player.audio_set_volume(int(Controls.current_input[10:]))  # probably needed to set it to [10:]
        except NameError:
            player_not_defined()
        except ValueError:
            print("Please enter a valid number")

    @staticmethod
    def ismute():
        try:
            if Song.player.audio_get_mute() == 0:
                print("|::|Player is not muted")
            else:
                print("|::|Player is muted")
        except NameError:
            player_not_defined()

    @staticmethod
    def skip():
        dummy = False  # idk why this is needed
        try:
            Song.player.stop()
        except NameError:
            player_not_defined()
            return

        if Controls.current_play_number + 1 >= len(PlayList.playlist):  # ends playlist
            Controls.current_play_number = 0
            print("Finished playing playlist")
            return  # to reduce nesting

        if len(PlayList.playlist) is not 0 and Controls.current_play_number + 1 < len(PlayList.playlist):
            Controls.current_play_number += 1
            thr = threading.Thread(target=Song.play, args=(dummy, ), kwargs={})
            thr.start()  # start next song

    @staticmethod
    def back():
        dummy = False  # still no idea
        try:
            Song.player.stop()
        except NameError:
            player_not_defined()
        if len(PlayList.playlist) is not 0 and Controls.current_play_number is not 0:
            Controls.current_play_number -= 1
            thr = threading.Thread(target=Song.play, args=(dummy, ), kwargs={})
            thr.start()

    @staticmethod
    def restart():
        dummy = False  # because of threads
        try:
            Song.player.stop()
        except NameError:
            player_not_defined()
            return
        thr = threading.Thread(target=Song.play, args=(dummy, ), kwargs={})
        thr.start()

    @staticmethod
    def mute():
        try:
            Song.player.audio_set_mute(True)
        except NameError:
            player_not_defined()
        print("|::| Muted")

    @staticmethod
    def toggle_mute():
        try:
            Song.player.audio_toggle_mute()
        except NameError:
            player_not_defined()
        print("|::| Mute toggled")


class Directory(object):
    @staticmethod
    def cd_go_back():
        os.system('clear')  # only in terminal, not cross-compatible
        old_path = os.getcwd()  # is need to always get one level higher up in the folder system
        i = len(old_path) - 1
        is_before_new_path = True
        new_path = ""  # bad name, new_path is the one that is one level higher up in the folder system
        while i > 0:
            if old_path[i] == '/':
                is_before_new_path = False

            if not is_before_new_path:
                new_path += old_path[i]

            i -= 1

        os.chdir('/' + new_path[::-1])  # [::-1] reverses string, because the while loop started from behind

    @staticmethod
    def cd_subfolder(subfolder_number, is_recursive):
        os.system('clear')  # only in terminal
        subfolder_name = os.listdir(os.getcwd())[subfolder_number - 1]   # only the number of the subfolder gets passed,
        try:  # for simplicity reasons
            os.chdir(os.getcwd() + "/" + subfolder_name)
        except OSError:
            if not is_recursive:  # doesn't check for songs, only enters subfolders
                PlayList.add_song(subfolder_number - 1)  # adds song to playlist if number is pressed

        print(os.getcwd())

    @staticmethod
    def input_directories():
        while True:  # breaks out of loop, instead of creating extra variable, for convenience
            os.system('clear')  # only in terminal
            print('Select from 0 to ', end='', flush=True)
            print(len(os.listdir(os.getcwd())) + 1)
            print("-1:/Exit from file/directory search")
            print("0:/..")
            i = 1  # to be able to print numbers in front of subdirectories
            for current_subfolder in os.listdir(os.getcwd()):  # outputs the current subfolders
                print(str(i) + ":/" + current_subfolder)
                i += 1
            sub_folder_number = 0  # was previously set to 20, changed to 0 because it doesn't matter
            print(":>", end="")  # line before input
            try:
                sub_folder_number = int(input())
            except ValueError:
                print("Wrong input, try again")

            if sub_folder_number == 0:
                Directory.cd_go_back()

            elif sub_folder_number == -1:  # exit the music/folder selector
                break  # instead of excess variable, looks cleaner

            elif len(os.listdir(os.getcwd())) >= sub_folder_number > 0:
                Directory.cd_subfolder(sub_folder_number, False)  # changes cwd to selected subfolder


class PlayList(object):
    playlist = list()  # used like a global variable without the fuckup of a gloabl variable

    @staticmethod
    def restart_playlist():
        dummy = False
        try:
            Song.player.stop()
        except NameError:
            player_not_defined()
            return

        Controls.current_play_number = 0
        thr = threading.Thread(target=Song.play, args=(dummy, ), kwargs={})
        thr.start()

    @staticmethod
    def sort_playlist():
        try:  # try except to stop the song that is currently playing, but doesn't matter if no song is playing
            Song.player.stop()
        except:
            print("", end="")

        Controls.current_play_number = 0
        PlayList.sort()

    @staticmethod
    def delete_playlist():
        try:
            Song.player.stop()
        except NameError:
            print("", end="")
        print("|::| deleting the current playlist")
        Controls.current_play_number = 0
        PlayList.playlist.clear()

    @staticmethod
    def add():
        length = len(os.listdir(os.getcwd()))
        i = 0
        while i < length:  # going through every file or directory in the current folder
            PlayList.add_song(i)
            root_path = os.listdir(os.getcwd())[i]
            pattern = '*.flac'
            for root, dirs, files in os.walk(root_path):
                for filename in fnmatch.filter(files, pattern):
                    PlayList.playlist.append(os.path.join(root, filename))  # actually adding to playlist
            pattern = '*.mp3'
            for root, dirs, files in os.walk(root_path):
                for filename in fnmatch.filter(files, pattern):
                    PlayList.playlist.append(os.path.join(root, filename))  # actually adding to playlist
            i += 1  # while loop looks better than for loop in this application (only in python3)

    @staticmethod
    def add_song(file_number):
        filename, file_extension = os.path.splitext(os.listdir(os.getcwd())[file_number])
        if file_extension == ".mp3" or file_extension == ".flac":
            PlayList.playlist.append(os.getcwd() + "/" + os.listdir(os.getcwd())[file_number])
            # print("|::| Adding file number " + str(file_number + 1) + " to Playlist")

    @staticmethod
    def format_time(whole_time):
        hour = whole_time // 3600
        whole_time %= 3600
        minutes = whole_time // 60
        whole_time %= 60
        seconds = whole_time
        print("Duration: %d:%d:%d" % (hour, minutes, seconds))

    @staticmethod
    def show_playlist():
        os.system('clear')  # only in terminal
        i = 0
        playlist_duration = 0
        while i < len(PlayList.playlist):  # every song in the playlist
            audiofile = eyed3.load(PlayList.playlist[i])
            playlist_duration += int(audiofile.info.time_secs)  # count playlist duration
            print(str(i + 1) + "|: ", end="")
            try:
                print(audiofile.tag.artist + ' - ' + audiofile.tag.title)
            except TypeError:  # if there are no tags
                print(PlayList.playlist[i])  # just print the filename with the whole file path
            i += 1
        PlayList.format_time(playlist_duration)

    @staticmethod
    def sort():
        exchange = True
        passnum = len(PlayList.playlist)
        try:
            while passnum > 0 and exchange:
                exchange = False
                for i1 in range(len(PlayList.playlist) - 1):
                    audiofile1 = eyed3.load(PlayList.playlist[i1])
                    audiofile2 = eyed3.load(PlayList.playlist[i1 + 1])
                    if int(audiofile1.tag.track_num[0]) > int(audiofile2.tag.track_num[0]):
                        exchange = True
                        temp = PlayList.playlist[i1]
                        PlayList.playlist[i1] = PlayList.playlist[i1 + 1]
                        PlayList.playlist[i1 + 1] = temp
                passnum -= 1
        except:  # eyed3 fails on specific mp3 files no idea why
            print("|EE| Sorting failed, check your mp3Tags, but could also be a problem of eyed3,", end="")
            print(" I have no control over neither")

    @staticmethod
    def shuffle_playlist():
        try:  # try except to stop the song that is currently playing, but doesn't matter if no song is playing
            Song.player.stop()
        except:
            print("", end="")

        Controls.current_play_number = 0
        print("shuffling Playlist")
        random.shuffle(PlayList.playlist)


class Song(object):
    player = vlc.MediaPlayer("")

    @staticmethod
    def show():  # tried to make a progress bar, is not possible by using APIs,
        try:  # because it would disrupt every other Thread, and wouldn't align/format correctly
            Song.player.get_state()
        except NameError:
            player_not_defined()
            return
        try:
            audiofile = eyed3.load(PlayList.playlist[Controls.current_play_number])
            print(audiofile.tag.artist + ' - ' + audiofile.tag.title)
            print('Album: ' + audiofile.tag.album)
            print('Track number: ' + str(int(audiofile.tag.track_num[0])))
            print('Path:  ' + PlayList.playlist[Controls.current_play_number])
        except IndexError:
            print("|EE| Please define first a playlist")
        except TypeError:
            print("Can't Show Tags of MP3 File when there aren't any")

    @staticmethod
    def play(dummy):
        audiofile = eyed3.load(PlayList.playlist[Controls.current_play_number])

        print("", end="\r")
        try:
            print('|' + str(Controls.current_play_number + 1) + '::' + str(len(PlayList.playlist)) + '| Now playing: ' +
                  audiofile.tag.artist + ' - ' + audiofile.tag.title, end="")
        except TypeError:
            print('|' + str(Controls.current_play_number + 1) + '::' + str(len(PlayList.playlist)) + '| Now playing: ' +
                  PlayList.playlist[Controls.current_play_number], end="")
        print('\n>', end="")
        Song.player = vlc.MediaPlayer("file://" + PlayList.playlist[Controls.current_play_number])
        Song.player.play()

        duration = int(audiofile.info.time_secs)
        Controls.current_duration = duration
        for i in range(0, int(duration)):
            while str(Song.player.get_state()) == "State.Paused" or str(Song.player.get_state()) == "State.Stopped":
                time.sleep(1)  # to not progress the for loop while paused/stopped
            time.sleep(1)
            if duration is not Controls.current_duration:  # Trick to kill thread when a song is skipped: when the
                return  # duration of the song is not the same as most recent song, then the thread gets killed

        if len(PlayList.playlist) is not 0 and Controls.current_play_number + 1 < len(PlayList.playlist):
            Controls.current_play_number += 1
            thr = threading.Thread(target=Song.play, args=(dummy, ), kwargs={})
            thr.start()  # recursive calling to play next song
        else:
            print("\n|::| Finished playing Playlist\n>", end="")

    @staticmethod
    def skipto():
        print("Skip to track number: ", end="")  # TODO: do the same as with setvolume
        try:
            Song.player.stop()
            Controls.current_play_number = int(input()) - 1
        except TypeError:
            return

        if len(PlayList.playlist) is not 0 and Controls.current_play_number < len(PlayList.playlist):
            thr = threading.Thread(target=Song.play, args=(dummy, ), kwargs={})
            thr.start()  # start new thread, old thread get killed automatically by trick
        else:
            print("Invalid number entered")

    @staticmethod
    def skipto2():
        try:
            Song.player.stop()
            Controls.current_play_number = int(Controls.current_input[6:]) - 1
        except TypeError:
            return

        if len(PlayList.playlist) is not 0 and Controls.current_play_number < len(PlayList.playlist):
            thr = threading.Thread(target=Song.play, args=(dummy, ), kwargs={})
            thr.start()  # start new thread, old thread get killed automatically by trick
        else:
            print("Invalid number entered")


def player_not_defined():
    print("|EE|To access this command, select music with cd and play music with play")


print("\n|;;| Current Directory: " + os.getcwd())
while Controls.current_input is not "exit": # this while could be True because the effective exit is with a elif and break
    print(">", end="")
    try:
        Controls.current_input = input()
        Controls.current_input.replace(" ", "")  # to concentate spaces, only with heading and trailing spaces
    except ValueError:  # if no string is entered (maybe not even possible)
        print("Wrong input, try again")

    if Controls.current_input == "cd":
        Directory.input_directories()

    elif Controls.current_input == "addp":
        PlayList.add()

    elif Controls.current_input == "showp":
        PlayList.show_playlist()

    elif Controls.current_input == "show":
        Song.show()

    elif Controls.current_input == "play":
        dummy = True  # still no idea why threads always need an extra argument, kinda dumb
        if len(PlayList.playlist) is not 0:
            thr = threading.Thread(target=Song.play, args=(dummy, ), kwargs={})
            thr.start()

    elif Controls.current_input == "pause":
        try:
            Song.player.pause()
        except NameError:
            player_not_defined()

    elif Controls.current_input == "stop":
        try:
            Song.player.stop()
        except NameError:
            player_not_defined()

    elif Controls.current_input == "delp":
        PlayList.delete_playlist()

    elif Controls.current_input == "clear":
        os.system('clear')  # not cross compatible, only in terminal

    elif Controls.current_input == "togglemute":
        Controls.toggle_mute()

    elif Controls.current_input == "mute":
        Controls.mute()

    elif Controls.current_input == "unmute":
        Controls.unmute()

    elif Controls.current_input == "ismute":
        Controls.ismute()

    elif Controls.current_input == "getvolume":
        Controls.getvolume()

    elif Controls.current_input == "setvolume":
        Controls.setvolume()

    elif Controls.current_input[:9] == "setvolume":
        Controls.setvolume2()

    elif Controls.current_input == "skip":
        Controls.skip()

    elif Controls.current_input == "back":  # exactly the same as skip, except reversed
        Controls.back()

    elif Controls.current_input == "restart":
        Controls.restart()

    elif Controls.current_input == "restartp":
        PlayList.restart_playlist()

    elif Controls.current_input == "sortp":
        PlayList.sort_playlist()

    elif Controls.current_input == "shufflep":
        PlayList.shuffle_playlist()

    elif Controls.current_input == "help":
        print("possible inputs:")
        print("  |exit          |stops music and exits mp3Player")
        print("  |play          |starts playlist !When paused, to resume the song type pause again, not play!")
        print("  |cd            |change directory and select single songs")
        print("  |addp          |add the whole current directory to the playlist")
        print("  |showp         |show the current playlist")
        print("  |delp          |stops music and deletes the current playlist")
        print("  |show          |shows the current song")
        print("  |pause         |pauses the current song or resumes it")
        print("  |stop          |stops the current song")
        print("  |clear         |clears the command line")
        print("  |skip          |skips the current song")
        print("  |back          |goes back one song")
        print("  |restart       |restarts current song")
        print("  |restartp      |restarts playlist")
        print("  |togglemute    |toggles mute of this player")
        print("  |mute          |mutes this player")
        print("  |unmute        |unmutes this player")
        print("  |ismute        |outputs mute status")
        print("  |getvolume     |outputs volume")
        print("  |setvolume     |sets  volume")
        print("  |sortp         |stops music and sorts playlist after track number")
        print("  |skipto        |stops music and skips to entered song number")
        print("  |shufflep      |stops music and randomizes playlist")

    elif Controls.current_input == "skipto":
        Song.skipto()

    elif Controls.current_input[:6] == "skipto":
        Song.skipto2()

    elif Controls.current_input == "exit":
        break

os.system('pkill python3')
